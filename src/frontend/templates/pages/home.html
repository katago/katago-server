{% extends 'base.html' %}

{% load i18n %}
{% load custom_translation %}

{% block extra_html_head_stuff %}
<link type="text/css" href="/static/css/elo-graph.css" rel="stylesheet" />

<script type="text/javascript" src="/static/js/d3.v6.min.js"></script>

{% if run %}
{% url 'networks-for-elo-list' as networks_for_elo_list_url %}
<script>
var api_url = "{{networks_for_elo_list_url|escapejs}}";
var run_name = "{{run.name|escapejs}}";

function makeGraph() {
  d3.json(api_url + "?run__name=" + run_name).then(function(networks) {
    // Extract unique network sizes
    var networkSizes = new Set(networks.map(network => network["network_size"]));
    // Natural numeric sort
    var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
    var compare = function(a,b) {
      aIsRandom = a.toLowerCase() == "random";
      bIsRandom = b.toLowerCase() == "random";
      if(aIsRandom && bIsRandom)
        return 0;
      if(aIsRandom)
        return -1;
      if(bIsRandom)
        return 1;
      return collator.compare(a,b);
    };
    networkSizes = Array.from(networkSizes).sort(compare);

    console.log(networkSizes);

    var eloPerLogGamma = Math.log10(Math.E) * 400.0;
    for(var i = 0; i<networks.length; i++) {
      var network = networks[i];
      network["time"] = new Date(network["created_at"]);
      network["elo"] = network["log_gamma"] * eloPerLogGamma;
      network["elostdev"] = network["log_gamma_uncertainty"] * eloPerLogGamma;
    }
    var minCreatedAt = d3.min(networks.map(network => network["time"]));
    var maxCreatedAt = d3.max(networks.map(network => network["time"]));
    var minDataRows = d3.min(networks.filter(network => !!network["total_num_data_rows"]).map(network => network["total_num_data_rows"]));
    var maxDataRows = d3.max(networks.filter(network => !!network["total_num_data_rows"]).map(network => network["total_num_data_rows"]));
    if(!minDataRows)
      minDataRows = 0;
    if(!maxDataRows)
      maxDataRows = 10000;

    var eloGraphDiv = d3.select("#eloGraph");

    // These are internal coordinates to the SVG - the actual size is scaled to whatever
    // size can fit on the user's browser, through CSS magic.
    var wholeGraphWidth = 800;
    var wholeGraphHeight = 540;

    var svg =
        eloGraphDiv
        .append("div")
        .classed("svg-container", true)
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 " + wholeGraphWidth + " " + wholeGraphHeight)
        .classed("svg-content-responsive", true);

    // Set aside space for axes
    var axisMargin = {top: 10, right: 30, bottom: 30, left: 60};
    // The space of the graph to plot stuff, after taking out the axes
    var graphSpace =
        svg
        .append("g")
        .attr("transform","translate(" + axisMargin.left + "," + axisMargin.top + ")");
    var graphSpaceWidth = wholeGraphWidth - axisMargin.left - axisMargin.right;
    var graphSpaceHeight = wholeGraphHeight - axisMargin.top - axisMargin.bottom;

    // X axis
    var xScale = null;
    var xScaleIsTime = false;
    var xScaleIsDataRows = false;
    var xScaleIsLogDataRows = false;
    var xDomainMin = null;
    var xDomainMax = null;
    var xAxis = d3.axisBottom(d3.scaleLinear()).tickSize(-graphSpaceHeight*1.0);

    //Functions to switch between different x axis scalings
    var setXScaleAsTime = function() {
      xScaleIsTime = true;
      xScaleIsDataRows = false;
      xScaleIsLogDataRows = false;

      var buffer = 0.01 * (maxCreatedAt.getTime() - minCreatedAt.getTime());
      xDomainMin = new Date(minCreatedAt.getTime()-buffer);
      xDomainMax = new Date(maxCreatedAt.getTime()+buffer*2);
      xScale =
        d3.scaleTime()
        .domain([xDomainMin, xDomainMax])
        .range([0, graphSpaceWidth]);
      xAxis.scale(xScale).ticks(10);
    };
    var setXScaleAsDataRows = function() {
      xScaleIsTime = false;
      xScaleIsDataRows = true;
      xScaleIsLogDataRows = false;

      var buffer = 0.01 * (maxDataRows - minDataRows);
      xDomainMin = minDataRows-buffer;
      xDomainMax = maxDataRows+buffer*2;
      xScale =
        d3.scaleLinear()
        .domain([xDomainMin, xDomainMax])
        .range([0, graphSpaceWidth]);
      xAxis.scale(xScale).ticks(10,"~s");
    };
    var setXScaleAsDataRowsLog = function() {
      xScaleIsTime = false;
      xScaleIsDataRows = false;
      xScaleIsLogDataRows = true;

      var maxDataRowsOr10k = Math.max(maxDataRows,10000);
      var buffer = 0.2 * (maxDataRows - minDataRows);
      xDomainMin = Math.min(minDataRows + 500000, maxDataRowsOr10k * 0.02);
      xDomainMax = maxDataRowsOr10k + buffer;
      xScale =
        d3.scaleLog()
        .domain([xDomainMin, xDomainMax])
        .range([0, graphSpaceWidth]);
      xAxis.scale(xScale).ticks(15,"~s");
    };

    setXScaleAsTime();

    var xAxisContent = graphSpace.append("g").attr("transform", "translate(0," + graphSpaceHeight + ")");
    xAxis(xAxisContent);

    // Takes the xDomain and finds a reasonable y elo range to capture all networks that fall within that range of time.
    var computeYDomainFromXDomain = function(xDomain) {
      var filtered;
      if(xScaleIsTime)
        filtered = networks.filter(network => network["time"] >= xDomain[0] && network["time"] <= xDomain[1]);
      else
        filtered = networks.filter(network => network["total_num_data_rows"] >= xDomain[0] && network["total_num_data_rows"] <= xDomain[1]);

      var minElo = d3.min(filtered.map(network => network["elo"] - Math.min(300, 2.5 * network["elostdev"])));
      var maxElo = d3.max(filtered.map(network => network["elo"] + Math.min(300, 2.5 * network["elostdev"])));
      // No elements
      if(minElo === undefined || maxElo === undefined) {
        minElo = 0;
        maxElo = 100;
      }
      var eloBuffer = 0.01 * (maxElo - minElo);
      minElo = minElo - eloBuffer;
      maxElo = maxElo + eloBuffer;
      //Also stretch out a little by scale
      if(maxElo > 0)
        maxElo *= 1.01;
      if(minElo > 0)
        minElo *= 0.99;

      return [minElo, maxElo];
    };

    // Y axis
    var yScale =
        d3.scaleLinear()
        .domain(computeYDomainFromXDomain(xScale.domain()))
        .range([graphSpaceHeight, 0]);
    var yAxis = d3.axisLeft(yScale).tickSize(-graphSpaceWidth*1.0).ticks(20);
    var yAxisContent = graphSpace.append("g");
    yAxis(yAxisContent);
    var unzoomedYDomainMin = yScale.domain()[0];
    var unzoomedYDomainMax = yScale.domain()[1];

    // Colors
    var colorScale = d3.scaleSequential(d3.interpolateWarm).domain([0,networkSizes.length-1]);
    var colorDict = {};
    var brighterColorDict = {};
    for(var i = 0; i<networkSizes.length; i++) {
      colorDict[networkSizes[i]] = colorScale(networkSizes.length-i-1);
      brighterColorDict[networkSizes[i]] = d3.rgb(colorScale(networkSizes.length-i-1)).brighter(0.5);
    }

    var escapeHtml = function(s) {
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Tooltip on hover
    var body = d3.select("body");
    var tooltip =
        body
        .append("div")
        .classed("eloGraphTooltip",true)
        .style("visibility", "hidden");
    // Translate the tooltip to be just to the lower right of the mouse position of the event
    var translateToolTip = function(event) {
      // We set it relative to the body because the tooltip div is appended to the body div
      // We append it to the body div so that the tooltip automatically resizes and wraps if it would
      // overflow body boundaries
      var bodyRect = body.node().getBoundingClientRect();
      tooltip
        .style("left", (event.clientX - bodyRect.left + 20) + "px")
        .style("top", (event.clientY - bodyRect.top + 20) + "px")
    };
    var toolTipMouseOver = function(event,network) {
      tooltip
        .html(escapeHtml(network["name"]) + "<br>" +
              escapeHtml(network["created_at"]) + "<br>" +
              "Elo " + network["elo"].toFixed(1) + " +/- " + (2 * network["elostdev"]).toFixed(1))
        .style("visibility", "visible");
      translateToolTip(event);
    };
    var toolTipMouseMove = function(event,network) {
      translateToolTip(event);
    };
    var toolTipMouseLeave = function() {
      tooltip
        .style("visibility", "hidden");
    };

    // Add a clipPath, so that things outside this area won't be drawn.
    var clip =
        graphSpace
        .append("defs")
        .append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", graphSpaceWidth)
        .attr("height", graphSpaceHeight)
        .attr("x", 0)
        .attr("y", 0);

    // Create a subelement that holds the data alone, clipped
    var dataSpace =
        graphSpace.append('g')
        .attr("clip-path", "url(#clip)");

    // Declare function now, it gets set later below
    var rerenderDataAfterScaling = null;

    // Handle brushing for zooming
    var justAfterBrushing = false;
    var recentlyClicked = false;
    function noLongerRecentlyClicked() { recentlyClicked = false; }

    // Translate a brushing result into a zoom
    var updateChartForBrush = function(event) {
      if(justAfterBrushing)
        return false;
      extent = event.selection;
      if(!extent) {
        if(!recentlyClicked) {
          recentlyClicked = true;
          setTimeout(noLongerRecentlyClicked, 300);
          return false;
        }
        //Upon a double-click with at most 300ms of tolerance, restore the original zoom
        var newDomain = [xDomainMin, xDomainMax];
        xScale.domain(newDomain);
        yScale.domain(computeYDomainFromXDomain(newDomain));
      }
      else {
        //Do nothing on zero or negative extent
        if(extent[1] <= extent[0])
          return false;

        var newDomain = [xScale.invert(extent[0]), xScale.invert(extent[1])];
        xScale.domain(newDomain);
        yScale.domain(computeYDomainFromXDomain(newDomain));
        // Remove the brush instead of letting it continue to display
        // Also the act of doing this will cause updateChartForBrush to be recursively called
        // back into, so suppress the effects of this with justAfterBrushing so that the recursive
        // calls return immediately.
        justAfterBrushing = true;
        dataSpace.select(".brush").call(brush.move, null)
        justAfterBrushing = false;
      }

      // Re-render now that the zoom is applied to the scales
      rerenderDataAfterScaling(200);
    };

    // Add brushing for zooming. We add brush FIRST so that the data points are on top and can be hovered
    var brush =
        d3.brushX()
        .extent([[0,0],[graphSpaceWidth,graphSpaceHeight]])
        .on("end", updateChartForBrush);
    dataSpace
      .append("g")
      .attr("class", "brush")
      .call(brush);

    // Now add data points
    var baseDataRadius = 2;
    var baseStrokeWidth = 1.5;
    var largeRadiusBonus = 2;
    var largeStrokeWidthBonus = 1.5;

    var curDataRadius = baseDataRadius;
    var curStrokeWidth = baseStrokeWidth;
    dataSpace.append('g')
      .selectAll("line")
      .data(networks)
      .enter()
      .append("line")
      .attr("class", network => "dataUncertainty " + "dataUncertainty_" + network["network_size"])
      .attr("stroke-width", curStrokeWidth)
      .style("stroke", network => brighterColorDict[network["network_size"]])
      .on("mouseover", toolTipMouseOver)
      .on("mousemove", toolTipMouseMove)
      .on("mouseleave", toolTipMouseLeave);
    dataSpace.append('g')
      .selectAll("circle")
      .data(networks)
      .enter()
      .append("circle")
      .attr("r", curDataRadius)
      .attr("class", network => "dataPoint " + "dataPoint_" + network["network_size"])
      .style("fill", network => colorDict[network["network_size"]])
      .on("mouseover", toolTipMouseOver)
      .on("mousemove", toolTipMouseMove)
      .on("mouseleave", toolTipMouseLeave);

    // Renders the data and axes
    rerenderDataAfterScaling = function(transitionDuration) {
      xAxis(xAxisContent.transition().duration(transitionDuration));
      yAxis(yAxisContent.transition().duration(transitionDuration));

      // Compute a ratio with which to scale the line thicknesses and such as we zoom in.
      var xRatio = (xScale.domain()[1] - xScale.domain()[0]) / (xDomainMax - xDomainMin);
      var yRatio = (yScale.domain()[1] - yScale.domain()[0]) / (unzoomedYDomainMax - unzoomedYDomainMin);
      var ratio = Math.max(xRatio,yRatio);
      curStrokeWidth = baseStrokeWidth / Math.max(0.2, Math.sqrt(ratio));
      curDataRadius = baseDataRadius / Math.max(0.2, Math.sqrt(ratio));

      var lines = dataSpace.selectAll("line");
      var circles = dataSpace.selectAll("circle");
      if(transitionDuration > 0) {
        lines = lines.transition().duration(transitionDuration);
        circles = circles.transition().duration(transitionDuration);
      }
      if(xScaleIsTime) {
        lines
          .attr("x1", network => xScale(network["time"]) )
          .attr("y1", network => yScale(network["elo"] - 2.0 * network["elostdev"]))
          .attr("x2", network => xScale(network["time"]) )
          .attr("y2", network => yScale(network["elo"] + 2.0 * network["elostdev"]))
          .attr("stroke-width",curStrokeWidth)
          .attr("visibility", "visible");
        circles
          .attr("cx", network => xScale(network["time"]))
          .attr("cy", network => yScale(network["elo"]))
          .attr("r",curDataRadius)
          .attr("visibility", "visible");
      }
      else if(xScaleIsDataRows) {
        lines
          .attr("x1", network => xScale(network["total_num_data_rows"] ? network["total_num_data_rows"] : 0))
          .attr("y1", network => yScale(network["elo"] - 2.0 * network["elostdev"]))
          .attr("x2", network => xScale(network["total_num_data_rows"] ? network["total_num_data_rows"] : 0))
          .attr("y2", network => yScale(network["elo"] + 2.0 * network["elostdev"]))
          .attr("stroke-width",curStrokeWidth)
          .attr("visibility", network => network["total_num_data_rows"] ? "visible" : "hidden");
        circles
          .attr("cx", network => xScale(network["total_num_data_rows"] ? network["total_num_data_rows"] : 0))
          .attr("cy", network => yScale(network["elo"]))
          .attr("r",curDataRadius)
          .attr("visibility", network => network["total_num_data_rows"] ? "visible" : "hidden");
      }
      else if(xScaleIsLogDataRows) {
        lines
          .attr("x1", network => xScale(network["total_num_data_rows"] > 1 ? network["total_num_data_rows"] : 1))
          .attr("y1", network => yScale(network["elo"] - 2.0 * network["elostdev"]))
          .attr("x2", network => xScale(network["total_num_data_rows"] > 1 ? network["total_num_data_rows"] : 1))
          .attr("y2", network => yScale(network["elo"] + 2.0 * network["elostdev"]))
          .attr("stroke-width",curStrokeWidth)
          .attr("visibility", network => network["total_num_data_rows"] > 1 ? "visible" : "hidden");
        circles
          .attr("cx", network => xScale(network["total_num_data_rows"] ? network["total_num_data_rows"] : 1))
          .attr("cy", network => yScale(network["elo"]))
          .attr("r",curDataRadius)
          .attr("visibility", network => network["total_num_data_rows"] > 1? "visible" : "hidden");
      }
    };
    rerenderDataAfterScaling(0);

    // Enable buttons
    d3.select("#eloGraphTimeButton").on("click", function () {
      setXScaleAsTime();
      xAxis.scale(xScale);
      yScale.domain(computeYDomainFromXDomain(xScale.domain()));
      rerenderDataAfterScaling(0);
    });
    d3.select("#eloGraphDataRowsButton").on("click", function () {
      setXScaleAsDataRows();
      xAxis.scale(xScale);
      yScale.domain(computeYDomainFromXDomain(xScale.domain()));
      rerenderDataAfterScaling(0);
    });
    d3.select("#eloGraphDataRowsLogButton").on("click", function () {
      setXScaleAsDataRowsLog();
      xAxis.scale(xScale);
      yScale.domain(computeYDomainFromXDomain(xScale.domain()));
      rerenderDataAfterScaling(0);
    });

    //Add legend
    graphSpace
      .selectAll(".eloLegend")
      .data(networkSizes)
      .enter()
      .append("g")
      .classed("eloLegend",true)
      .append("text")
      .attr("x", graphSpaceWidth * 0.85)
      .attr("y", function(networkSize,i) { return graphSpaceHeight * 0.80 + i * 20; })
      .text(networkSize => networkSize)
      .style("fill", networkSize => colorDict[networkSize])
      .style("font-size", 15)
      .on("mouseover", function(mouseEvent,networkSize) {
        console.log(networkSize);
        d3.selectAll(".dataUncertainty_" + networkSize).attr("stroke-width",curStrokeWidth + largeStrokeWidthBonus);
        d3.selectAll(".dataPoint_" + networkSize).attr("r",curDataRadius + largeRadiusBonus);
      })
      .on("mouseleave", function(mouseEvent,networkSize) {
        d3.selectAll(".dataUncertainty_" + networkSize).attr("stroke-width",curStrokeWidth);
        d3.selectAll(".dataPoint_" + networkSize).attr("r",curDataRadius);
      });

    console.log(networkSizes);
    console.log([minCreatedAt, maxCreatedAt]);
  });
}

document.addEventListener("DOMContentLoaded", makeGraph);

</script>
{% endif %}

{% endblock extra_html_head_stuff %}


{% block title %}{% trans "KataGo Distributed Training" %}{% endblock %}


{% block content %}

<h1 class="title">{% trans "KataGo Distributed Training" %}</h1>

<h2 class="is-size-2"> {% trans "How to Contribute" %} </h2>

TODO :)

<h2 class="is-size-2 mt-4"> {% trans "Stats" %} </h2>

<h3 class="is-size-3"> {% trans "Data" %} </h3>

{% blocktrans %}
<p>
Across all time, {{ num_total_contributors }} distinct users have uploaded {{ total_num_training_rows }} rows of training data and {{ total_num_games }} games.
<p class="mt-1">
Within the last week, {{ num_recent_contributors }} distinct users have uploaded
{{ num_recent_training_rows }} rows of training data and {{ num_recent_games }} new games.
{% endblocktrans %}

<h5 class="is-size-5 mt-3"> {% trans "Top contributors in the last week:" %} </h5>

<table class="table">
  <tr>
    <th> {% trans "User" %} </th>
    <th class="has-text-right"> {% trans "Training Rows Generated" %} </th>
    <th class="has-text-right"> {% trans "Training Games" %} </th>
    <th class="has-text-right"> {% trans "Rating Games" %} </th>
  </tr>
  {% for user in top_recent_user_list %}
  <tr>
    <td> {{ user.username }} </td>
    <td class="has-text-right"> {{ user.total_num_training_rows|as_n_training_rows_str }} </td>
    <td class="has-text-right"> {{ user.total_num_training_games|as_n_training_games_str }} </td>
    <td class="has-text-right"> {{ user.total_num_rating_games|as_n_rating_games_str }} </td>
  </tr>
  {% endfor %}
</table>

{% if run %}

<h3 class="is-size-3"> {% trans "Networks" %} </h3>

{% blocktrans %}
A total of {{ num_networks_this_run_excluding_random }} networks have
been produced for the current run.
{% endblocktrans %}

<p>
{% if latest_network %}

{% url 'current_run_networks' as current_run_networks %}
{% blocktrans with latest_network_url=latest_network.model_file.url networks_url=url %}
Download the latest network <a href="{{ latest_network_url }}">here!</a>
<p>
See <a href="{{ current_run_networks }}">Networks page</a> for older networks.
{% endblocktrans %}

{% endif %}

<h5 class="is-size-5 mt-3"> {% trans "Approximate Elo Ratings Graph" %} </h3>

{% blocktrans %}
Graph is based on {{ num_rating_games_this_run }} rating games using mid to high hundreds of playouts.
<p>
Vertical bars indicate approximately a 95% confidence interval.
<p>
Nets play a variety of nearby nets to avoid rock-paper-scissors issues, but
ratings might still be mildly inflated due to only playing other KataGo nets.
<p class="mt-1">
Click and drag to zoom. Double-click to reset zoom.
{% endblocktrans %}

<div id="eloGraphButtons" class="my-2">
{% blocktrans %}
<button id="eloGraphTimeButton" class="button">Graph By Time</button>
<button id="eloGraphDataRowsButton" class="button">Graph By Data Rows (linear)</button>
<button id="eloGraphDataRowsLogButton" class="button">Graph By Data Rows (log)</button>
{% endblocktrans %}
</div>

<div id="eloGraph"></div>
{% endif %}

{% endblock content %}
